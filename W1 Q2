class Queue:
    def __init__(self):
        self.list = []

    def put(self, data):
        self.list.append(data)

    def get(self):
        if len(self.list) > 0:
            data = self.list[0]
            del self.list[0]
            return data

class Graph:
    def __init__(self):
        # Dictionary to store vertices
        self.vertices = {}
        self.adjmatrix = [] #2D list

    def add_vertex(self, vertex):
        #check if the vertex is already in there, if not we will add it
        if vertex not in self.vertices:
            
            # use the index to give a uniqe value for each vertex
            index = len(self.vertices)
            
            # add it to the vertext dectionary
            self.vertices[vertex] = index

            # Extend adjacency matrix for the new vertex
            """
            chatGPT explanation: appends a new row to the adjacency matrix, where the length of the row is determined by the variable index, 
            and all elements in the row are initially set to zero. This is often used to initialize the adjacency matrix with the appropriate number of columns when adding a new vertex to the graph. Each zero represents the absence of a connection between the corresponding vertex and the newly added vertex.
            """
            for row in self.adjmatrix:
                row.append(0)
            self.adjmatrix.append([0] * (index+1))  # Extend each row with one more zero , I am not sure why but if I did not add 1 it will be index error

            # first we will check if the verticexes are in our vertex dic ( keys) ,if true we will get the value that present the index


    def remove_vertex(self, vertex):
        if vertex in self.vertices:

            index = self.vertices[vertex]

            del self.vertices[index]
            del self.adjmatrix[index]
            for row in self.adjmatrix:
                del row[index]

    def add_edge(self, from_vertex, to_vertex):
        if from_vertex in self.vertices and to_vertex in self.vertices:
            from_index = self.vertices[from_vertex]
            to_index = self.vertices[to_vertex]

            # update the releation (edges), 1 = there a connection, it is a 2D list so we need to 2 indix
            self.adjmatrix[from_index][to_index] = 1
            self.adjmatrix[to_index][from_index] = 1

    def remove_edge(self, from_vertex, to_vertex):
        if from_vertex in self.vertices and to_vertex in self.vertices:
            from_index = self.vertices[from_vertex]
            to_index = self.vertices[to_vertex]

            self.adjmatrix[from_index][0]
            self.adjmatrix[to_index][0]

    def display_matrix(self):
        print("Adjacency Matrix:")
        for row in self.adjmatrix:
            print(row)

    def is_network_connected(self):
        for row in self.adjmatrix:
            if sum(row) == 0:  # If a row sums to 0, vertex has no connections
                return False
        return True if self.adjmatrix else False


    def print_matrix(self):
        result=' |'

        line="\n"+("-"*(2+len(self.adjmatrix)*2))+"\n"
        line='\n'
        for key in self.vertices:
            result+=f"{key}|"

        result+=line

        keys=list(self.vertices.keys())

        for row in range(len(self.adjmatrix)):
            result+=f"{keys[row]}|"

            for col in range(len(self.adjmatrix[row])):

                result+=f"{self.adjmatrix[row][col]}|"

            result+=line

        print(result)

# Testing the Graph class
network = Graph()

# Add vertices and connect them
network.add_vertex("A")
network.add_vertex("B")
network.add_edge("A", "B")
network.display_matrix()
print("Output:",network.is_network_connected())
# Verify is all computers are connected
#is_network_connected(network)
#Output: True

# Add more computers to the network and connect them
network.add_vertex("C")
network.add_vertex("C")
network.add_edge("C", "D")

# Verify is all computers are connected
#is_network_connected(network)
#Output: False

network.print_matrix()
