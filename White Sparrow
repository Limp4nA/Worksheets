''' start of TURKI`s implementation (ID: 5554912)--------------------------------------------------------------------'''
import pygame
import random
import math

pygame.init()

# behind the scenes sitting variables
# ----------------------------------------------------------------
SCREEN_WIDTH = 900
SCREEN_HEIGHT = 900

FPS = 60
clock = pygame.time.Clock()

# the width and height in pixels from the sprite_sheet
CARD_WIDTH = 25
CARD_HEIGHT = 36
CARD_SIZE = 1.5 * 4 # <-- leave the (* 4) and only change the first number in the left
CARD_SPEED = 90 # pixel per frame
CARD_Y_ADJUSTMENT = 50 # <-- it represent the distance (in pixels) between the cards and the bottem side of the screen
CARD_Y = (SCREEN_HEIGHT - CARD_HEIGHT * CARD_SIZE) - CARD_Y_ADJUSTMENT

DECK_OF_CARDS_X = SCREEN_WIDTH - 250
DECK_OF_CARDS_Y = 75
DECK_OF_CARDS_SIZE = 1.2 * 4 # <-- leave the (* 4) and only change the first number in the left
DECK_OF_CARDS_SPACING = .5
DECK_OF_CARDS_ROTATION = 170 # in degrees
DECK_OF_CARDS_SPEED = 20

Background_Color = 'purple'
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

pygame.event.set_blocked(pygame.MOUSEMOTION)

cards_x_adjustment = 0 # <--- this variable is explained in the update_cards_x_adjustment()
X_destination = None # <--- this variable is explained in the update_X_destination()

TEXT_COLOR = 'white'
TEXT_X = 10
TEXT_Y = 10
TEXT_SIZE = 100
TEXT_OFF_SET = 100 # is the distance in pixels between each text
font = pygame.font.Font('m6x11.ttf', TEXT_SIZE)
score_reached_color = [255, 255, 0]
score_color = TEXT_COLOR
shake_score = False
shake_score_amount = 1
texts = {}

MESSAGE_COLOR = 'pink'
MESSAGE_X = SCREEN_WIDTH / 2 - 200
MESSAGE_Y = SCREEN_HEIGHT / 2
MESSAGE_SIZE = 50
MESSAGE_FADE_SPEED = 2
DEFAULT_ALPHA_VALUE = 200
ALPHA_VALUE = 0
MESSAGES_DISTANCE = 200
messages = {'score': ''}


Y_SLIDE = math.pi
SIN_COEFFICIENT = 1
SMALL_ADDING_AMOUNT = .9
CARDS_SLIDE_SPEED = 0.02
slide_out = False

card_is_moving_to_hand = False
card_is_moving_from_deck = False

# ----------------------------------------------------------------

class Card:

    # loading the sprite sheet into a variable
    sprite_sheet = pygame.image.load('CuteCardsPixel_outline.png').convert_alpha()

    def __init__(self, val: str,suit: str):
        #each card is defined by value and a suit and a x position

        # the variable val that has been passed by the constructor has the type of str
        # so, we call get_value to convert the value into an integer
        self.val: int = self.get_value(val)

        self.suit: str = suit

        # Note: the point that represent the Card image is in the top left corner
        # meaning, if the x = SCREEN_WIDTH, the card will be outside the border of the screen
        self.x = SCREEN_WIDTH

        self.y = CARD_Y

    def get_value(self,val):

        # we try if val can be converted by the int() function
        try:
            result = int(val)

        # if we get an error that mean val is a litter
        except:
            if val == 'A':
                result = 1
            elif val == 'J':
                result = 11
            elif val == 'Q':
                result = 12
            elif val == 'K':
                result = 13

        return result

    def get_image(self) -> pygame.surface.Surface:

        # this function return an image of the card (self) from the sprite sheet

        # to understand how it works take a look at the file CuteCardsPixel_outline.png
        # and imagine it to look like a 2D list

        # the column index is the easiest to calculate it is just  the value of the card - 1
        card_col = self.val - 1


        # the row index depends on the suit of the card
        card_row = None

        if self.suit == 'Clubs':
            card_row = 0
        elif self.suit == 'Diamonds':
            card_row = 1
        elif self.suit == 'Spades':
            card_row = 2
        elif self.suit == 'Hearts':
            card_row = 3

        # here we get the x-y position of the card in the sprite sheet
        # and we multiply by the card width and height to jump from card to card horizontally and vertically
        card_x = card_col * CARD_WIDTH
        card_y = card_row * CARD_HEIGHT

        # we initialize an empty black image with a size of [CARD_WIDTH, CARD_HEIGHT]
        image = pygame.Surface((CARD_WIDTH, CARD_HEIGHT)).convert_alpha()

        # we overwrite the image of the card in the sprite sheet into the image
        # and the arguments for the blit() are as follows
        # 1 - a Surface which is in this case is the (sprite sheet)
        # 2 - the x-y position in the image
        # 3 - the rectangular area of the sprite sheet that we want to cut in the form (x1, y1, x2, y2)
        image.blit(Card.sprite_sheet, [0, 0], [card_x, card_y, card_x + CARD_WIDTH, card_y + CARD_HEIGHT])

        # then we transform the size of the image by a scaler
        # the first arg is the image and the second is a list that stores the scale amount of the width and height
        image = pygame.transform.scale(image, [CARD_WIDTH * CARD_SIZE , CARD_HEIGHT * CARD_SIZE])

        #there are still some black pixels in the four corners, and this function will trim the image and remove it
        # by giving it the color that we want to remove
        image.set_colorkey('black')

        # and the image is ready to be returned
        return image
class Stack:

    def __init__(self):
        self.list=[]

    def push(self,data):
        return self.list.append(data)

    def pop(self):
        if self.is_empty():
            return None
        else:
            return self.list.pop()

    def peek(self):
        if self.is_empty():
            return None
        else:
            return self.list[-1]

    def is_empty(self):
        return len(self.list)==0
class Deck_of_cards:

    def __init__(self):

        # we start by creating a list that holds all the 52 cards
        values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        suits = ['Clubs', 'Diamonds', 'Spades', 'Hearts']
        cards = []
        for suit in suits:
            for value in values:
                cards.append(Card(value, suit))

        # here we shuffle the cards by the using the random.shuffle() function
        random.shuffle(cards)

        # then we create a stack that we hold of the shuffled cards
        self.cards = Stack()
        self.cards.list = cards

        # the size attribute will hold the number of cards in the Stack (card)
        self.size = 52

        # this list will hold all the images in the deck of cards
        self.cards_back_images = []

        # this loop will initialize the images list
        for i in range(len(cards)):

            # if the card is red --> get the red image
            if cards[i].suit == 'Diamonds' or cards[i].suit == 'Hearts':
                current_image = red_card_back_image

            # if the card is black --> get the black image
            else:
                current_image = black_card_back_image

            # each element in the cards_back_images will be a dictionary that holds the image and the x-y position
            current_dictionary = {'image': current_image,
                                  'x': DECK_OF_CARDS_X,
                                  'y': DECK_OF_CARDS_Y - (DECK_OF_CARDS_SPACING * i)}

            self.cards_back_images.append(current_dictionary)



    def draw(self) -> Card:

        # don't forget to decrement the size when drawing a card from the Stack
        self.size -= 1

        # remove the last card and return it
        return self.cards.pop()
class Timer:

    # Timer object is a timer that have a duration in milliseconds
    # and a switch (on, off) represented by the active attribute
    # and a function to execute when the timer finishes

    def __init__(self, duration: int, repeat=False, autostart=False, function=None):

        self.duration = duration
        self.active = False
        self.func = function

        # start_time will be used to calculate if we surpassed the duration or not
        self.start_time = 0

        # if the repeat is True, then the moment the timer finished it will start again automatically
        self.repeat = repeat

        # when a timer object is created it will not be active, however, if the autostart argument is True
        # it will be activated
        if autostart:
            self.activate()

    def activate(self):
        # this function start the timer
        self.active = True

        # and we update start_time by the current time
        self.start_time = pygame.time.get_ticks()

    def deactivate(self):
        # this function ends the timer
        self.active = False


        # self.start_time = 0

        # if the timer is on repeat
        if self.repeat:
            # start again
            self.activate()

    def update(self):

        # in this method we check if the timer finished
        # by getting the difference between start_time and current_time and see
        # if the result is greater than the duration

        # note: the method has to be called in every frame


        # check of the timer is active
        if self.active:

            # we get current_time
            current_time = pygame.time.get_ticks()

            # check the difference
            if current_time - self.start_time >= self.duration:

                # if the function exist
                if self.func:

                    # call it
                    self.func()

                # turn off the timer
                self.deactivate()
def draw() -> None:

    # this function draws a cards to the player hand
    global player_hand , player_hand_images ,deck_of_cards
    player_hand.append(deck_of_cards.draw())

    #then we add the card`s image to the player_hand_images list
    player_hand_images.append(player_hand[-1].get_image())
def update_texts() -> None:
    # it updates all the texts
    global texts , level, max_cards, score, player_hand , target

    texts['level'] = font.render(f'Level {level}', True, TEXT_COLOR)
    texts['multiplier'] = font.render(f'multiplier {multiplier}', True, TEXT_COLOR)
    texts['score'] = font.render(f'Score {score}', True, score_color)
    texts['target'] = font.render(f'Target {target}', True, TEXT_COLOR)
    texts['max_cards'] = font.render(f'Cards {len(player_hand)}/{max_cards}', True, TEXT_COLOR)
def draw_texts() -> None:
    # this function update the texts by calling update_texts() then draws them in the top left corner of the screen
    update_texts()

    iterate = 0

    global shake_score_amount, score, target

    # here is the drawing
    for text in texts:
        # screen.blit(texts[text], (TEXT_X, TEXT_Y + (TEXT_OFF_SET * iterate)))

        if text == 'score':

            if shake_score:
                screen.blit(texts[text], (TEXT_X +shake_score_amount, TEXT_Y + (TEXT_OFF_SET * iterate)+shake_score_amount))
                shake_score_amount *= -1
            else:
                screen.blit(texts[text], (TEXT_X, TEXT_Y + (TEXT_OFF_SET * iterate)))

                message_image = font.render(messages[text], True, MESSAGE_COLOR)
                message_image.set_alpha(ALPHA_VALUE)

                screen.blit(message_image, (TEXT_X + 390, TEXT_Y + (TEXT_OFF_SET * iterate)))


        else:
            screen.blit(texts[text], (TEXT_X, TEXT_Y + (TEXT_OFF_SET * iterate)))

        iterate += 1

    # screen.blit(texts['level'] , (10,TEXT_OFF_SET * 0 + beggining))
    # screen.blit(texts['max_cards'] , (10,TEXT_OFF_SET * 1 + beggining))
    # screen.blit(texts['score'] , (10,TEXT_OFF_SET * 2 + beggining))
    # # screen.blit(messages['score'], (340, TEXT_OFF_SET * 2 + beggining))
    # screen.blit(texts['target'] , (10,TEXT_OFF_SET * 3 + beggining))
def update_X_destination() -> float:

    # X_destination variable represents the X position destination of the moving card that has been drawn

    global player_hand, max_cards, X_destination

    # this number represents the interval of all the possible x position any card can be
    # which is:  0 <= X <=  cards_line_length
    cards_line_length = SCREEN_WIDTH - CARD_WIDTH * CARD_SIZE

    # then we divide it by the max_cards to git the distance between each card. to have an evenly spread distribution
    places_for_the_cards = cards_line_length / max_cards

    #then the X_destination of the moving cards is equal to the distance between each card * the moving card order
    X_destination = places_for_the_cards * len(player_hand)
def moving_card() -> None:

    # this function is responsible for moving the card that has been drawn

    global player_hand, card_is_moving_to_hand, X_destination , card_is_moving_from_deck

    # logically the moving card is the last card in the player hand
    moving_card = None

    # first of we check is there a moving card to the hand
    if card_is_moving_from_deck:

        # moving_card = player_hand[-1]
        moving_card_dictionary = deck_of_cards.cards_back_images[deck_of_cards.size]

        if moving_card_dictionary['x'] + DECK_OF_CARDS_SPEED < SCREEN_WIDTH + 50:
            moving_card_dictionary['x'] += DECK_OF_CARDS_SPEED
        else:
            card_is_moving_from_deck = False
            card_is_moving_to_hand = True


    elif card_is_moving_to_hand:
        moving_card = player_hand[-1]

        # we check if we shift the moving card to the left by CARD_SPEED will it be still in the right side of the X_destination
        if moving_card.x - CARD_SPEED > X_destination:
            # if yes shift the moving card
            moving_card.x -= CARD_SPEED

        else:
            # the moving card has reached the destination
            moving_card.x = X_destination

            #now, there is no moving cards
            card_is_moving_to_hand = False
def draw_hand() -> None:

    # this function just print all the player hand in the screen
    # by iterating through (player_hand for the x and y position) and (player_hand_images for the images)
    global screen, player_hand, player_hand_images, cards_x_adjustment, Y_SLIDE, slide_out
    global SIN_COEFFICIENT, SMALL_ADDING_AMOUNT, CARDS_SLIDE_SPEED


    if slide_out:
        card_y = CARD_Y * (SIN_COEFFICIENT * math.sin(Y_SLIDE) + SIN_COEFFICIENT + SMALL_ADDING_AMOUNT)

    elif len(player_hand) >= 1:
        card_y = player_hand[0].y


    for i in range(len(player_hand)):

        card_x = player_hand[i].x + cards_x_adjustment

        screen.blit(player_hand_images[i],[card_x , card_y])

    if slide_out:

        Y_SLIDE -= CARDS_SLIDE_SPEED

        if card_y >= SCREEN_HEIGHT:
            slide_out = False

            for card in player_hand:
                card.y = SCREEN_HEIGHT
def update_cards_x_adjustment() -> None:

    # this function updates cards_x_adjustment.
    # the only factor that can change cards_x_adjustment value in in-game runtime is max_cards
    # so, we only need to call this function when max_cards changes

    # the purpose of cards_x_adjustment is to make the player hand cards align in the middle not in the left corner,
    # so we increment all the cards x value by cards_x_adjustment

    # without the x_adjustment, cards will stuck to the left-side border of the screen and there will be a gap in the right side
    # we need to git the gap and divide it by two and the result will be the cards_x_adjustment value

    # to see the differance with or without the cards_x_adjustment, change the value of this boolean variable to False
    with_cards_x_adjustment = True

    if with_cards_x_adjustment:

        global cards_x_adjustment

        cards_line_length = SCREEN_WIDTH - CARD_WIDTH * CARD_SIZE
        last_card_x_pos = (cards_line_length / max_cards) * (max_cards -1)

        right_side_gap = (SCREEN_WIDTH - last_card_x_pos - (CARD_WIDTH * CARD_SIZE))
        cards_x_adjustment = right_side_gap/2
def update_timers() -> None:

    #we just call the update() method for all timers
    global timers

    for timer in timers.keys():
        timers[timer].update()
def get_card_back_image(color: str) -> pygame.surface.Surface:

    # this function can return the back of the (black/red) from the sprite sheet

    # it has the same logic as draw_hand() function

    card_x = 14 * CARD_WIDTH
    if color == 'black':
        card_y = 2 * CARD_HEIGHT

    elif color == 'red':
        card_y = 3 * CARD_HEIGHT

    card_back_image = pygame.Surface((CARD_WIDTH, CARD_HEIGHT)).convert_alpha()
    card_back_image.blit(Card.sprite_sheet, [0, 0], [card_x, card_y, card_x + CARD_WIDTH, card_y + CARD_HEIGHT])
    card_back_image = pygame.transform.scale(card_back_image, [CARD_WIDTH * DECK_OF_CARDS_SIZE, CARD_HEIGHT * DECK_OF_CARDS_SIZE])

    # the new thing is we rotate the image to give a 3D effect
    card_back_image = pygame.transform.rotate(card_back_image, DECK_OF_CARDS_ROTATION)

    card_back_image.set_colorkey('black')
    return card_back_image
def draw_deck_of_cards() -> None:

    # this function draws the deck_of_cards

    # however, there is a problem, when the player draw a card, this function will not draw the last card
    # the played had drawn because it is no longer in the deck therefore we cant draw the moving card in the screen.
    # the solution is in this if statement down below

    # if there is a moving card from the deck, let the_drawn_card = 1 so we count the card in the next for loop
    if card_is_moving_from_deck:
        the_drawn_card = 1
    else:
        the_drawn_card = 0


    for i in range(deck_of_cards.size + the_drawn_card):

        # we game the image and the x-y of each card in the deck_of_card
        image = deck_of_cards.cards_back_images[i]['image']
        x = deck_of_cards.cards_back_images[i]['x']
        y = deck_of_cards.cards_back_images[i]['y']

        # we draw the image in the screen
        screen.blit(image, [x, y])
def reset_messages() -> None:

    # reset the messages alpha value and delete all the messages except the score

    global messages, ALPHA_VALUE

    # reset the alpha_value to show all the messages that will pop out
    ALPHA_VALUE = DEFAULT_ALPHA_VALUE

    messages = {'score': messages['score']}
def draw_messages() -> None:

    global ALPHA_VALUE, MESSAGE_FADE_SPEED, messages

    if ALPHA_VALUE >= 0:

        off_set = 0

        for message in messages:

            if message != 'score':

                message_image = font.render(messages[message], True, MESSAGE_COLOR)
                message_image.set_alpha(ALPHA_VALUE)

                screen.blit(message_image, [MESSAGE_X + (off_set * MESSAGES_DISTANCE), MESSAGE_Y])

                off_set += 1

        ALPHA_VALUE -= MESSAGE_FADE_SPEED
def set_slide_out() -> None:

    global set_slide_out, Y_SLIDE, slide_out, SIN_COEFFICIENT, SMALL_ADDING_AMOUNT

    slide_out = True
    Y_SLIDE = math.asin((1 - SIN_COEFFICIENT - SMALL_ADDING_AMOUNT) / SIN_COEFFICIENT)
    # print(Y_SLIDE)
def update_score_shake_and_color():
    global score, target, score_color, shake_score, shake_score_amount, score_reached_color

    if score >= target:
        score_color = score_reached_color
    else:
        score_color = TEXT_COLOR

    if score >= target * 1.5:
        shake_score = True

        score_reached_color = [255, 255 * (target * 1.5) / score , 0]

        if shake_score_amount < 3.3:
            shake_score_amount = score/(target * 1.5)
        else:
            shake_score_amount = 3.3
    else:
        shake_score = False

''' end of TURKI`s implementation (ID: 5554912)----------------------------------------------------------------------'''

''' start of LAMA`s implementation (ID: 5555093)---------------------------------------------------------------------'''

#local import in order to add and controle the sounds within the game
from pygame import mixer

#pre-initialization(random values so we can make sure it works properly)
pygame.mixer.pre_init(44100, -16,2,512)

#initialize
mixer.init()

#variables
VOLUME = 0.4
MUSIC_DELAY = 4000


#load sounds & set the volume

global sounds
sounds= {
   'one_card': pygame.mixer.Sound('card.wav'),
   'button_click': pygame.mixer.Sound('button_click.wav')
           }

sounds['one_card'].set_volume(VOLUME)
sounds['button_click'].set_volume(VOLUME)

#load background sound (we donot have to sighn avairable bec. it will always plays in backgraound)
pygame.mixer.music.load("piano-loops.wav")

# play the background sound with 4000 ms delay that more comfortable for users since it does not start strong
pygame.mixer.music.play(-1,0.0, MUSIC_DELAY)

''' end of LAMA`s implementation (ID: 5555093)-----------------------------------------------------------------------'''

''' start of ARDA`s implementation ----------------------------------------------------------------------'''
# ----------------------------------------------------------------------------------------------------
''' end of ARDA`s implementation------------------------------------------------------------------------'''


# this function will be called by a timer when the level is finished.
def end_level() -> None:
    #some one should implement it
    pass


def update_all() -> None:

    # Note: we call this function in every frame. 60 times per second


    # here is shows all of the changes of the screen to the user
    pygame.display.update()

    # it makes the program run at 60 FPS
    clock.tick(FPS)

    # here where the fill the screen with pink all of it.
    # and if you don`t understant why we do that every frame, then try to remove this line and run the program
    screen.fill(Background_Color)

    # here we draw all of the text in the top left corner
    draw_texts()

    # here we draw the cards in the screen
    draw_hand()

    # here we draw the deck_of_cards in the screen
    draw_deck_of_cards()

    # here we move the card that is being drawn if the (card_is_moving_to_hand is True)
    moving_card()

    # TODO we need to move this function to the place where we start each level.
    #  we only need to update the value at the begging of every level not every frame
    update_cards_x_adjustment()

    #we update all of the timers to check if they are finished
    update_timers()

    draw_messages()



# images loading
#-----------------------
black_card_back_image = get_card_back_image('black')
red_card_back_image = get_card_back_image('red')
#-----------------------

# game sitting variables
#-----------------------
player_hand = []
player_hand_images = []
deck_of_cards = Deck_of_cards()
level = 1
max_cards = 5
score = 0
target = 20
target_increment = 5
multiplier = 1
timers = {
    #we dont wont the second the player draw the last card, the level ends. with this timer we solve this issue
    'end level': Timer(2000, function = end_level),
    'card slide': Timer(1000, function = set_slide_out)
}
#-----------------------

#Game Loop ------------------------------
run = True
while run:

    #update everything for this frame
    update_all()

    # the event handler
    for event in pygame.event.get():

        # shut down the program of the player preses the X symbol in the screen
        if event.type == pygame.QUIT:
             run = False

        # if the player presses any key
        if event.type == pygame.KEYUP or event.type == pygame.MOUSEBUTTONUP:

            # if no card is moving and the player can draw more cards
            if not card_is_moving_from_deck and not card_is_moving_to_hand and len(player_hand) < max_cards:
                # there is a card moving now so play a card sound 

                card_is_moving_from_deck = True
                sounds['one_card'].play()

                # update the x destination for the new card that has been drawn
                update_X_destination()

                # draw a card
                draw()

                # reset the messages alpha value and delete all the messages except the score
                reset_messages()

                # set the score message
                messages['score'] = f"+{player_hand[-1].val}"

                update_score_shake_and_color()

                # if the player draws the maximum amount of cards
                if len(player_hand) == max_cards:

                    timers['card slide'].activate()

                    #activate the timer for ending the level. because we want to give the player a couple of seconds to see what he/she has drawn
                    timers['end level'].activate()

pygame.quit()
