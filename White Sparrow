''' start of TURKI`s implementation (ID: 5554912)--------------------------------------------------------------------'''

# NOTES:
# 1 - The reference point (x,y) of all the images in this program are in the top left corner
#     meaning, if x = SCREEN_WIDTH, the image will be outside the border of the screen
# 2 - All comments that explain a class or function are inside it and not on top of it, to make the Code Folding
#     feature provided by pycharm hide any comment explanation when I fold a function/class, for better code navigation
import pygame
import random
import math

# starting pygame library running
pygame.init()
# stopping pygame to track mouse movement because it unneeded and it will improve performance
pygame.event.set_blocked(pygame.MOUSEMOTION)

# start of behind the scenes sitting variables
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# ------ start of screen(GUI) sittings ------
Background_Color = [50, 90, 50]  # 'green'

# initialize the width and the height of the screen window
SCREEN_WIDTH = 1000
SCREEN_HEIGHT = 900

# setting up the screen image that we will draw everything into it
screen = pygame.surface.Surface([SCREEN_WIDTH, SCREEN_HEIGHT])

# initialize the display that will be used to show the game
# we put the "screen" into the display to show the player, the reason for that is to use shaking effects
display = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

# setting up the clock that runs the program to a Frame Rates of 60
FPS = 60
clock = pygame.time.Clock()

# the display screen will shake if this variable is set to True
screen_shake = False
# the range from (0, SCREEN_SHAKE_AMOUNT) that will be (in/de)cremented to the xy values per frame
SCREEN_SHAKE_AMOUNT = 12
# the duration in milliseconds of screen shake
SCREEN_SHAKE_TIME = 250

# ------ start of cards sittings ------
# the cards width and height in pixels taking from the sprite_sheet
CARD_WIDTH = 25
CARD_HEIGHT = 36
# the image scaler
CARD_SIZE = 6
# the speed of the cards sliding from the right side of the screen to the player hand in (pixel per frame)
CARD_SPEED = 90
# it represent the distance (in pixels) between the cards and the bottem side of the screen
CARD_Y_ADJUSTMENT = 100
# the Y value of (SCREEN_HEIGHT - CARD_HEIGHT * CARD_SIZE) it is where the cards are in the bottem of the screen
# then we subtract it by CARD_Y_ADJUSTMENT to give some space between the cards and the bottem edge
CARD_Y = (SCREEN_HEIGHT - CARD_HEIGHT * CARD_SIZE) - CARD_Y_ADJUSTMENT
# loading the cards sprite sheet
CARDS_SPRITE_SHEET = pygame.image.load('CuteCardsPixel_outline.png').convert_alpha()

# this starts the animation of the drawn card that starts on the right side of the screen to the player hand
# it becomes True when (card_is_moving_from_deck goes to False after it was True). in other words, after the top deck
# card disappears from the screen, to give the illusion that those two cards are one card that was flipped out-screen
card_is_moving_to_hand = False

# x_destination variable represents the X position destination of the moving card that has been drawn
# to go to the player hand. there are two variable that effects the value of cards_x_adjustment in in-game runtime:
# 1 - max_cards (AND) 2 - the order of the drawn card to the player hand
x_destination = None

# the purpose of cards_x_adjustment is to make the player hand cards align in the middle not in the left corner,
# by incrementing all the cards x value by cards_x_adjustment without the x_adjustment, cards will stick to the
# left-side border of the screen and there will be a gap on the right side we need to git the gap and divide it by
# two and the result will be the cards_x_adjustment value
# the only factor that can change cards_x_adjustment value in in-game runtime is max_cards
cards_x_adjustment = 0

# the speed of the falling cards in the menu background is determent by a
# random value in the range (FALLING_CARDS_MIN_SPEED, FALLING_CARDS_MAX_SPEED)
FALLING_CARDS_MAX_SPEED = 8
FALLING_CARDS_MIN_SPEED = 2

# ------ start of deck_of_cards sittings ------
# setting up deck of cards X&Y values
DECK_OF_CARDS_X = SCREEN_WIDTH - 250
DECK_OF_CARDS_Y = 75
# image scaler
DECK_OF_CARDS_SIZE = 4.8
# the Y value distances between each card in the deck of cards
DECK_OF_CARDS_SPACING = .5
# the image rotation (in degrees) of the deck, to give a 3D effect
DECK_OF_CARDS_ROTATION = 170
# the speed of the deck of cards that are used to draw from it and in the reset animation (pixel per frame)
DECK_OF_CARDS_SPEED: int = 20

# this starts the animation of the drawn card from the deck to move to the right side of the screen
card_is_moving_from_deck = False


# here is the deck of card reset animation, it`s in 2 parts
# the part1 of the animation is the one that move the old deck to the right side of the screen then reset the deck.
# if the deck is empty, part1 will be skipped,
deck_of_cards_reset_part1 = False
# the part2 of the animation will start descending the new deck from the top of the screen
deck_of_cards_reset_part2 = False
# when drawing the deck in part2, the position of the deck in the screen will be (DECK_OF_CARDS_Y + part2_descend_y)
# and part2_descend_y will increase until it reaches 0
PART2_DESCEND_Y_DEFAULT_VALUE = -4 * DECK_OF_CARDS_Y
part2_descend_y = PART2_DESCEND_Y_DEFAULT_VALUE

# ------ start of text sittings ------
TEXT_COLOR = 'white'
TEXT_X = 10
TEXT_Y = 10
# image scaler
TEXT_SIZE = 100
# is the Y distances in pixels between each text
TEXT_OFF_SET = 100
# initializing two fonts for different text sizes
FONT = pygame.font.Font('m6x11.ttf', TEXT_SIZE)
SMALL_FONT = pygame.font.Font('m6x11.ttf', int(TEXT_SIZE/2))
# the variable that stores all the texts that will be writen in the top left corner of the screen
texts = {}
# the color of the score when it reach beyond the target
score_reached_color = [255, 255, 0] # yellow
# the starting color of the score
score_color = TEXT_COLOR
# if its True, the score will began to shake
shake_score = False
# the starting value of the shake amount, it will increase alongside the score
shake_score_amount = 1


# ------ start of messages sittings ------
# messages are a kind of text that will pop up into the screen if the player does something significant.
# then it fades away after a short period of time. The ALPHA value is responsible for the fade effect, whenever it
# decreases the images start to fade away.

MESSAGE_COLOR = [0, 0, 200]
MESSAGE_X = SCREEN_WIDTH / 2 - 50
MESSAGE_Y = SCREEN_HEIGHT / 2 - 150

# this variable store the original alpha value, it is used for alpha reset
DEFAULT_ALPHA_VALUE = 200
# we decrement the alpha_value by this speed variable
MESSAGE_FADE_SPEED = 2
# that variable that will be used to the messages alpha value
alpha_value = DEFAULT_ALPHA_VALUE

# the Y distance between each message
MESSAGES_DISTANCE = 100

# the variable that stores all the messages
messages = {'score': '', 'multiplier': ''}

# ------ start of cards slide-out animation sittings ------
# slide-out is the smooth animation of the player hand cards going out of the screen when the player hand is full of
# cards. to give this smoothness, I used a costume sin function that will be multiplied with the player cards Y values
# the give another Y values that will be used as the cards Y position in screen

# it starts the animation if it`s True
slide_out = False

# slide_dt += CARDS_SLIDE_SPEED each frame
CARDS_SLIDE_SPEED = 0.02

# to understand the function shape better, I recommend to plug the function into Desmos
# and to know that the sparting point is where Y = 1 and its decreasing toward Y = LOCAL_MINIMUM
SIN_COEFFICIENT = 1
LOCAL_MINIMUM = .9
COSTUME_SIN_FUNCTION = lambda t: (SIN_COEFFICIENT * math.sin(t) + SIN_COEFFICIENT + LOCAL_MINIMUM)

# the slide animation change of time, it will start at the point (slide_dt, 1) so when we MULTIPLY it with the
# player cards Y value, it won't change the cards images position
# I get it by solving the equation [COSTUME_SIN_FUNCTION(t) = 1]
DEFAULT_START_TIME = math.asin((1 - SIN_COEFFICIENT - LOCAL_MINIMUM) / SIN_COEFFICIENT)
slide_dt = DEFAULT_START_TIME

# ------ start of menu sittings ------
# everything regarding the main menu screen variables

TITLE_SIZE = 100

TITLE_FONT = pygame.font.Font('m6x11.ttf', TITLE_SIZE)
TITLE = "WHITE SPARROW"
TITLE_IMAGE = TITLE_FONT.render(f'{TITLE}', True, TEXT_COLOR)
TITLE_X = 17
TITLE_Y = 115

# welcome message
WELCOME = "WELCOME TO"
WELCOME_IMAGE = TITLE_FONT.render(f'{WELCOME}', True, TEXT_COLOR)
WELCOME_X = TITLE_X + 50
WELCOME_Y = TITLE_Y - 100

START = 'START'
START_IMAGE = SMALL_FONT.render(f'{START}', True, TEXT_COLOR)
START_X_SHIFT_FROM_BUTTON_X = 27

EXIT = 'EXIT'
EXIT_IMAGE = SMALL_FONT.render(f'{EXIT}', True, TEXT_COLOR)
EXIT_X_SHIFT_FROM_BUTTON_X = 37

# the color of all rectangles in the game
RECT_COLOR = [90, 0, 0]  # dark red

# the dimensions of the menu rectangle
RECT_WIDTH = 620
RECT_HEIGHT = 210

RECT_X = (SCREEN_WIDTH - RECT_WIDTH) / 2
RECT_Y = SCREEN_HEIGHT * 0.1

# How wide (x-axis) and height (y-axis) is the black rectangle compared
# to the red rectangle to give an outline effect
OUTLINE_SIZE = 5


# the hovering of the title in the main menu uses a sin function, however, what makes this different from
# cards slide-out, in this animation we ADD the sin function to the TITLE_IMAGE Y value

# Title change of time
title_dt = 0

# Title hovering speed --> title_dt += TITLE_SPEED (per frame)
TITLE_SPEED = 0.03

# the vertical distance between the maximum and the minimum points for MENU_IMAGE
TITLE_MOVING_DISTANCE = 50

# the variable that will be added to the MENU_IMAGE Y position to give the hovering effect
title_hovering = 0


# if it True, it will start the menu exit animation after the player presses the start button
menu_exiting = False
# if it True, it will start the menu enter animation after the player losses
menu_entering = False
# the y-axis shifter for all (menu screen) and (game screen) images during entering and exiting animation
menu_animation_shift = 0
# the animation change of time
menu_animation_dt = 0
# menu_animation_dt += menu_animation_speed per frame
menu_animation_speed = 0.01

# the distance between the menu buttons and the left or right sides of the background rectangle
MENU_BUTTONS_RECT_HORIZONTAL_DISTANCE = 20
# the distance between the menu buttons and the top and bottom sides of the background rectangle
MENU_BUTTONS_RECT_VERTICAL_DISTANCE = 20



# ------ start of reset option sittings ------
# reset option is the option that will be given to the player to whether he/she resets the deck or not
# the reset option has three states, 1-entering animation -> 2-waiting for the player input -> 3-exiting animation

# when this is True the reset option will pop up
reset_option_is_on = False
# the moment reset_option_is_on is True, this will also be True. until the entering animation finishes
reset_option_entering = False
# this will be True after the player input, and the exiting animation will start
reset_option_exiting = False

# in this part, the X&Y position are all relative to the reset option rectangle

WANT_TO_RESET = "WANT TO RESET"
WANT_TO_RESET_IMAGE = FONT.render(f'{WANT_TO_RESET}', True, TEXT_COLOR)
WANT_TO_RESET_X = OUTLINE_SIZE + 75
WANT_TO_RESET_Y = OUTLINE_SIZE + 10

THE_DECK = "THE DECK ?"
THE_DECK_IMAGE = FONT.render(f'{THE_DECK}', True, TEXT_COLOR)
THE_DECK_X = OUTLINE_SIZE + 155
THE_DECK_Y = OUTLINE_SIZE + 100

YES = 'YES'
YES_IMAGE = SMALL_FONT.render(f'{YES}', True, TEXT_COLOR)

NO = 'NO'
NO_IMAGE = SMALL_FONT.render(f'{NO}', True, TEXT_COLOR)

# the amount that will shift the "Yes" and "No" text to the right to center the text at the middle of the button
NO_X_SHIFT_FROM_BUTTON_X = 60
YES_X_SHIFT_FROM_BUTTON_X = 50

# reset option rectangle dimensions and position
RESET_OPTION_WIDTH = 700
RESET_OPTION_HEIGHT = 360
RESET_OPTION_X = (SCREEN_WIDTH - RESET_OPTION_WIDTH) / 2
RESET_OPTION_Y = 200

# while drawing the reset option the Y value of it will be RESET_OPTION_Y + reset_option_y_shifter
# this will make the reset option starts at the bottom of the screen, in each frame the reset_option_y_shifter
# 1- if entering: will be decreased by the RESET_OPTION_SPEED to give the rising effect of the reset option
# 2- if exiting: will be increased by the RESET_OPTION_SPEED to give the descending effect of the reset option
RESET_OPTION_Y_SHIFTER_DEFAULT_VALUE = SCREEN_HEIGHT + 100
reset_option_y_shifter = RESET_OPTION_Y_SHIFTER_DEFAULT_VALUE
RESET_OPTION_SPEED = 20

# the distance between the reset buttons and the left or right sides of the background rectangle
OPTION_BUTTONS_RECT_HORIZONTAL_DISTANCE = 90

# ------ start of suit symbols sittings ------
# this is where we set up the four suit symbols that are drawn in the game screen around the player hand

# image scaler as usual
SUIT_SIZE = 20

# setting up the Suits XY values

# the Y value of the top side
up_side = CARD_Y - 5 * SUIT_SIZE
# the Y value of the bottom side
down_side = CARD_Y + CARD_HEIGHT * CARD_SIZE
# the X value of the right side
right_side = SCREEN_WIDTH - SUIT_SIZE * 4
# the X value of the left side
left_side = 0
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of behind the scenes sitting variables


# start of Classes definitions
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
class Card:

    def __init__(self, val: str, suit: str, speed=None):
        # each card is defined by value and a suit and a x position

        # the variable val that has been passed by the constructor has the type of str
        # so, we call get_value to convert the value into an integer
        self.val: int = self.get_value(val)

        self.suit: str = suit

        # the position
        self.x = SCREEN_WIDTH
        self.y = CARD_Y

        # getting the image from the sprite sheet
        self.image = self.get_image()

        # the speed of the falling card, only used in the main menu screen
        self.speed = speed

    def get_value(self, val):

        # we try if val can be converted by the int() function
        try:
            result = int(val)

        # if we get an error that mean val is a litter
        except:
            if val == 'A':
                result = 1
            elif val == 'J':
                result = 11
            elif val == 'Q':
                result = 12
            elif val == 'K':
                result = 13

        return result

    def get_image(self) -> pygame.surface.Surface:

        # this function return an image of the card (self) from the sprite sheet

        # to understand how it works take a look at the file CuteCardsPixel_outline.png
        # and imagine it to look like a 2D list

        # the column index is the easiest to calculate it is just  the value of the card - 1
        card_col = self.val - 1

        # the row index depends on the suit of the card
        card_row = None

        if self.suit == 'Clubs':
            card_row = 0
        elif self.suit == 'Diamonds':
            card_row = 1
        elif self.suit == 'Spades':
            card_row = 2
        elif self.suit == 'Hearts':
            card_row = 3

        # here we get the x-y position of the card in the sprite sheet
        # and we multiply by the card width and height to jump from card to card horizontally and vertically
        card_x = card_col * CARD_WIDTH
        card_y = card_row * CARD_HEIGHT

        # we initialize an empty black image with a size of [CARD_WIDTH, CARD_HEIGHT]
        image = pygame.Surface((CARD_WIDTH, CARD_HEIGHT)).convert_alpha()

        # we overwrite the image of the card in the sprite sheet into the image
        # and the arguments for the blit() are as follows
        # 1 - a Surface which is in this case is the (sprite sheet)
        # 2 - the x-y position in the image
        # 3 - the rectangular area of the sprite sheet that we want to cut. in the form (x1, y1, x2, y2)
        image.blit(CARDS_SPRITE_SHEET, [0, 0], [card_x, card_y, card_x + CARD_WIDTH, card_y + CARD_HEIGHT])

        # then we transform the size of the image by a scaler
        # the first arg is the image and the second is a list that stores the scale amount of the width and height
        image = pygame.transform.scale(image, [CARD_WIDTH * CARD_SIZE, CARD_HEIGHT * CARD_SIZE])

        # there are still some black pixels in the four corners, and this function will trim the image and remove it
        # by giving it the color that we want to remove
        image.set_colorkey('black')

        # and the image is ready to be returned
        return image
class Stack:
    # the Stack class is just a copy from what we had learn from the IFP, nothing new about it

    def __init__(self):
        # initialize the list
        self.list = []

    def push(self, data):
        # add an element to the last index to the list
        return self.list.append(data)

    def pop(self):
        # removes the last element and then return it

        # if the Stack is not empty
        if not self.is_empty():
            # remove then return the last element
            return self.list.pop()

        # return nothing if its empty
        else:
            return None

    def peek(self):
        # returns the last element of the stack without removing it from the stack

        if self.is_empty():
            return None
        else:
            return self.list[-1]

    def is_empty(self):
        # returns True if the stack is empty
        return len(self.list) == 0
class Deck_of_cards:

    def __init__(self):

        # we start by creating two lists that holds all the 52 cards combinations
        values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        suits = ['Clubs', 'Diamonds', 'Spades', 'Hearts']

        # creating a sorted list of cards
        cards = []
        for suit in suits:
            for value in values:
                cards.append(Card(value, suit))

        # here we shuffle the cards by the using the random.shuffle() function
        random.shuffle(cards)

        # then we create a stack that we hold of the shuffled cards
        self.cards = Stack()
        self.cards.list = cards

        # the size attribute will hold the number of cards in the Stack (card)
        self.size = 52

        # this list will hold all the images in the deck of cards
        self.cards_back_images = []

        # this loop will initialize the images list
        for i in range(len(cards)):

            # if the card is red --> get the red image
            if cards[i].suit == 'Diamonds' or cards[i].suit == 'Hearts':
                current_image = red_card_back_image

            # if the card is black --> get the black image
            else:
                current_image = black_card_back_image

            # each element in the cards_back_images will be a dictionary that holds the image and the x-y position
            current_dictionary = {'image': current_image,
                                  'x': DECK_OF_CARDS_X,
                                  'y': DECK_OF_CARDS_Y - (DECK_OF_CARDS_SPACING * i)}

            self.cards_back_images.append(current_dictionary)

    def draw(self) -> Card:

        # don't forget to decrement the size when drawing a card from the Stack
        self.size -= 1

        # remove the last card and return it
        return self.cards.pop()
class Timer:

    # Timer object is a timer that have a duration in milliseconds
    # and a switch (on, off) represented by the active attribute
    # and a function to execute when the timer finishes

    def __init__(self, duration: int, repeat=False, autostart=False, function=None):

        self.duration = duration
        self.active = False
        self.func = function

        # start_time will be used to calculate if we surpassed the duration or not
        self.start_time = 0

        # if the repeat is True, then the moment the timer finished it will start again automatically
        self.repeat = repeat

        # when a timer object is created it will not be active, however, if the autostart argument is True
        # it will be activated
        if autostart:
            self.activate()

    def activate(self):
        # this function start the timer
        self.active = True

        # and we update start_time by the current time
        self.start_time = pygame.time.get_ticks()

    def deactivate(self):
        # this function ends the timer
        self.active = False

        # if the timer is on repeat
        if self.repeat:
            # start again
            self.activate()

    def update(self):

        # in this method we check if the timer finished
        # by getting the difference between start_time and current_time and see
        # if the result is greater than the duration

        # note: the method has to be called in every frame

        # check of the timer is active
        if self.active:

            # we get current_time
            current_time = pygame.time.get_ticks()

            # check the difference
            if current_time - self.start_time >= self.duration:

                # turn off the timer
                self.deactivate()

                # if the function exist
                if self.func:
                    # call it
                    self.func()
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of Classes definitions

# start of Draw Functions
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
def draw_texts() -> None:
    # this function update the texts by calling update_texts() then draws them in the top left corner of the screen
    update_texts()

    global shake_score_amount, score, target

    # count the number of iteration
    iterate = 0

    # here is the drawing
    for text in texts.keys():

        # current text Y is equal to the starting Y (TEXT_Y) shifted by (TEXT_OFF_SET * iterate) downwards
        current_y = TEXT_Y + (TEXT_OFF_SET * iterate)

        # if the text is about the score or the multiplier
        # the score and the multiplier text are associated with the score and multiplier messages
        if text == 'score' or text == 'multiplier':

            # get the message image for the score and the multiplier
            message_image = FONT.render(messages[text], True, MESSAGE_COLOR)

            # set the fading value to alpha_value
            message_image.set_alpha(alpha_value)

            # draw the message next to the text by 520 pixels to the right
            screen.blit(message_image, (TEXT_X + 520, current_y))

        # if the text is score and the shaking score animation is on
        if text == 'score' and shake_score:

            # get the random x and y off set from the range -> (-shake_score_amount, shake_score_amount)
            x_off_set = random.randint(0, int(shake_score_amount * 2)) - int(shake_score_amount)
            y_off_set = random.randint(0, int(shake_score_amount * 2)) - int(shake_score_amount)

            # draw the score text and move the X&Y positions by the off sets
            screen.blit(texts[text], (TEXT_X + x_off_set, current_y + y_off_set))

        # elif the menu exiting animation is on
        elif menu_exiting:

            # draw the text under the screen and in each frame, menu_animation_shift will decrease until
            # SCREEN_HEIGHT + (CARD_HEIGHT * CARD_SIZE) = -menu_animation_shift
            # therefor -> current_y + SCREEN_HEIGHT + (CARD_HEIGHT * CARD_SIZE) + menu_animation_shift = current_y
            screen.blit(texts[text],
                        (TEXT_X, current_y + SCREEN_HEIGHT + (CARD_HEIGHT * CARD_SIZE) + menu_animation_shift))

        # elif the menu entering animation is on
        elif menu_entering:
            # draw the next its original position at first, and in each frame will menu_animation_shift until its
            # under the screen
            screen.blit(texts[text],
                        (TEXT_X, current_y + menu_animation_shift))

        # if no animation is on
        else:
            # draw the text normally
            screen.blit(texts[text], (TEXT_X, current_y))

        # increment iterate by 1
        iterate += 1
def draw_hand() -> None:
    # this function just print all the player hand in the screen
    # by iterating through player_hand for the x and y position and its images
    global screen, player_hand, cards_x_adjustment, slide_dt, slide_out
    global CARDS_SLIDE_SPEED, COSTUME_SIN_FUNCTION

    # all cards of a player's hand share the same value of Y but differ in value of X

    # slide_out animation is on
    if slide_out:

        # current Y value is equal to the original Y value (CARD_Y) multiplied by the sin function
        current_card_y = CARD_Y * COSTUME_SIN_FUNCTION(slide_dt)
        update_slide_out_Y(current_card_y)


    # elif the player hand has cards
    elif len(player_hand):
        # current Y will be equal to the cards Y value
        # player_hand[0].y is equal to CARDS_Y most of the time, it changes after the slide out animation if finished
        current_card_y = player_hand[0].y

    # draw all player hand cards
    for i in range(len(player_hand)):
        # the cards X value in the screen is equal to the cards X shifted by the cards_x_adjustment to the right
        card_x = player_hand[i].x + cards_x_adjustment

        # draw the cards in the screen
        screen.blit(player_hand[i].image, [card_x, current_card_y])
def draw_deck_of_cards() -> None:
    # this function draws the deck_of_cards

    global deck_of_cards_reset_part2, part2_descend_y

    # there is a problem, when the player draw a card, this function will not draw the last card
    # the played had drawn because it is no longer in the deck therefore we cant draw the moving card in the screen.
    # the solution is in this if statement down below

    # if there is a moving card from the deck, let the_drawn_card = 1 so we count the card in the next for loop
    if card_is_moving_from_deck:
        the_drawn_card = 1
    else:
        the_drawn_card = 0

    for i in range(deck_of_cards.size + the_drawn_card):

        # we get the image and the x-y of each card in the deck_of_card
        image = deck_of_cards.cards_back_images[i]['image']

        x = deck_of_cards.cards_back_images[i]['x']

        y = deck_of_cards.cards_back_images[i]['y']

        # the logic of the two next if statements are explained before in draw_hand()
        if menu_exiting:
            y += SCREEN_HEIGHT + (CARD_HEIGHT * CARD_SIZE) + menu_animation_shift

        elif menu_entering:
            y += menu_animation_shift

        # the part2 of the animation is here in the draw_deck_of_cards() not in moving_card(),
        # because it is difficult to move all 52 card images to an exact xy location, unlike part1 where it
        # does not matter where do the cards really go as long as they are out of the screen

        # if the part2 of the reset animation is on
        elif deck_of_cards_reset_part2:
            y += part2_descend_y

        # we draw the image in the screen
        screen.blit(image, [x, y])

    # update descend y value for part2. note: it only works if deck_of_cards_reset_part2 is True
    update_part2_descend_y()
def show_display():
    # this is the function that is responsible for refreshing the display screen

    global menu_animation_dt, menu_exiting

    # fill the display screen with the Background_Color
    display.fill(Background_Color)

    # if screen shake animation is on
    if screen_shake:

        # get the random X&Y off sets value from the range -> (-SCREEN_SHAKE_AMOUNT , SCREEN_SHAKE_AMOUNT)
        # it shares the same logic with the score shake
        x_off_set = random.randint(0, SCREEN_SHAKE_AMOUNT * 2) - SCREEN_SHAKE_AMOUNT
        y_off_set = random.randint(0, SCREEN_SHAKE_AMOUNT * 2) - SCREEN_SHAKE_AMOUNT

        # draw the screen into the display screen with the X&Y off sets
        display.blit(screen, [x_off_set, y_off_set])

    else:
        # draw the screen into the display normally
        display.blit(screen, [0, 0])

    # show the display to the user
    pygame.display.update()
def draw_and_move_reset_option():

    # this function is responsible for drawing and moving the reset option that pop up to the player at the beginning
    # of every 3 levels.
    global reset_option_is_on, reset_option_y_shifter, reset_option_entering, reset_option_exiting

    # the function only works of the reset_option_is_on if True
    if reset_option_is_on:

        # draw the reset option and shift it at the Y axis by reset_option_y_shifter amount
        screen.blit(RESET_OPTION_IMAGE, [RESET_OPTION_X, RESET_OPTION_Y + reset_option_y_shifter])

        # draw the yes and no buttons and shift them at the Y axis by reset_option_y_shifter amount
        yes_button.draw(reset_option_y_shifter)
        no_button.draw(reset_option_y_shifter)

        # the "Yes" and "No" text Y value. the wanted value will the center the small text at the middle of the button
        small_texts_y = OPTION_BUTTONS_Y + start_button.image.get_height()/2 - 18

        # the small texts X value is equal to the button`s X position shifted by the shift amount for each small text
        yes_x = yes_button.x + YES_X_SHIFT_FROM_BUTTON_X
        no_x = no_button.x + NO_X_SHIFT_FROM_BUTTON_X

        # draw the small texts and shift them by the
        # reset_option_y_shifter for the entering and exiting animations
        screen.blit(YES_IMAGE, [yes_x, small_texts_y + reset_option_y_shifter])
        screen.blit(NO_IMAGE, [no_x, small_texts_y + reset_option_y_shifter])

        # if the entering animation is on
        if reset_option_entering:
            # we want to decrease the y shifter until it has no effect -> shifter = 0

            # if it is still positive
            if reset_option_y_shifter > 0:

                # shift it upwards by the speed
                reset_option_y_shifter -= RESET_OPTION_SPEED

            else:
                # turn of the y shifter
                reset_option_y_shifter = 0

                # and stop the entering animation
                reset_option_entering = False

        # else if the exiting animation is on
        elif reset_option_exiting:
            # we want to increase the y shifter until it shift the reset option image out-side the screen

            # see if the y shifter is smaller than its default value
            if reset_option_y_shifter < RESET_OPTION_Y_SHIFTER_DEFAULT_VALUE:

                # increment it to reach the default value
                reset_option_y_shifter += RESET_OPTION_SPEED

            else:
                # turn off the exiting animation and the reset option
                reset_option_exiting = False
                reset_option_is_on = False

                # reset the y shifter value
                reset_option_y_shifter = RESET_OPTION_Y_SHIFTER_DEFAULT_VALUE

        # if the entering and exiting animations are off -> the reset option is waiting for the user to press a button
        else:

            # check of the Yes button is presses
            if yes_button.is_pressed():
                # activate the timer for resetting the deck of cards
                timers['reset deck'].activate()

                # start the exiting animation
                reset_option_exiting = True

            # check of the No button is presses
            if no_button.is_pressed():

                # start the exiting animation
                reset_option_exiting = True
def draw_messages() -> None:
    # this function draw all the messages except the score and the multiplier messages,
    # they are drawn in the draw_texts()

    global alpha_value, MESSAGE_FADE_SPEED, messages

    # if the alpha value is positive -> no point for drawing if the messages are invisible
    if alpha_value > 0:

        # the y off set between each message
        y_off_set = 0

        for message in messages:

            # leave the score and multiplier messages alone
            if message != 'score' and message != 'multiplier':

                # creating the message images
                message_image = FONT.render(messages[message], True, MESSAGE_COLOR)

                # setting the alpha value to the message image for the fading effect
                message_image.set_alpha(alpha_value)

                # draw the message and shift then downwards by (y_off_set * MESSAGES_DISTANCE)
                screen.blit(message_image, [MESSAGE_X, MESSAGE_Y + (y_off_set * MESSAGES_DISTANCE)])

                # increment the off set
                y_off_set += 1

        # after the function is done drawing decrease the alpha value by the speed
        alpha_value -= MESSAGE_FADE_SPEED
def draw_symbols():
    # this function draws the suit symbols in the game screen
    global suit_images

    # for all symbols
    for sym in suit_images:

        # the suites X&Y value
        suit_x = 0
        suit_y = 0

        # if the suit is Spades
        if sym == 'Spades':
            # set the X&Y to the top right corner
            suit_x = right_side
            suit_y = up_side - SUIT_SIZE

        # if the suit is Hearts
        elif sym == 'Hearts':
            # set the X&Y to the top left corner
            suit_x = left_side
            suit_y = up_side + SUIT_SIZE

        # if the suit is Clubs
        elif sym == 'Clubs':
            # set the X&Y to the bottom left corner
            suit_x = left_side
            suit_y = down_side

        # if the suit is Diamonds
        elif sym == 'Diamonds':
            # set the X&Y to the bottom right corner
            suit_x = right_side
            suit_y = down_side

        # if menu exiting animation is on
        if menu_exiting:

            # shift the suit Y value downwards by [SCREEN_HEIGHT + (CARD_HEIGHT * CARD_SIZE) + menu_animation_shift]
            suit_y += SCREEN_HEIGHT + (CARD_HEIGHT * CARD_SIZE) + menu_animation_shift

        # if menu entering animation is on
        elif menu_entering:

            # shift the suit Y value downwards by menu_animation_shift
            suit_y += menu_animation_shift

        # draw the suit
        screen.blit(suit_images[sym], [suit_x, suit_y])
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of Draw Functions

# start of Update Functions
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# these function are used to update some specific variable values. update functions need to be called in each frame
# the purpose of these up clear based on their names
def update_part2_descend_y():
    global deck_of_cards_reset_part2, part2_descend_y

    # if deck resetting part2 animation in on
    if deck_of_cards_reset_part2:

        # shift the y descend downwards by DECK_OF_CARDS_SPEED / 3
        part2_descend_y += DECK_OF_CARDS_SPEED / 3

        # Y descend is not negative anymore
        if part2_descend_y >= 0:

            # stop part2 animation
            deck_of_cards_reset_part2 = False
            # reset the y descend
            part2_descend_y = PART2_DESCEND_Y_DEFAULT_VALUE
def update_slide_out_Y(current_card_y):
    global slide_out,slide_dt

    # if slide out animation is on
    if slide_out:

        # move the slide out animation change of time by the speed
        slide_dt -= CARDS_SLIDE_SPEED

        # if the cards Y value is below the screen
        if current_card_y >= SCREEN_HEIGHT:

            # stop the animation
            slide_out = False

            # let all the player hand cards Y value become under the screen
            for card in player_hand:
                card.y = SCREEN_HEIGHT
def update_texts() -> None:
    # it updates all the texts to the current variables values
    global texts, level, max_cards, score, player_hand, target

    texts['level'] = FONT.render(f'Level {level}', True, TEXT_COLOR)
    texts['multiplier'] = FONT.render(f'multiplier {multiplier}', True, TEXT_COLOR)
    texts['score'] = FONT.render(f'Score {score}', True, score_color)
    texts['target'] = FONT.render(f'Target {target}', True, TEXT_COLOR)
    texts['max_cards'] = FONT.render(f'Cards {len(player_hand)}/{max_cards}', True, TEXT_COLOR)
def update_X_destination() -> float:

    global player_hand, max_cards, x_destination

    # this number represents the interval of all the possible x position any card can be
    # which is:  0 <= X <=  cards_line_length
    cards_line_length = SCREEN_WIDTH - CARD_WIDTH * CARD_SIZE

    # then we divide it by the max_cards to git the distance between each card. to have an evenly spread distribution
    places_for_the_cards = cards_line_length / max_cards

    # then the x_destination of the moving cards is equal to the distance between each card * the moving card order
    x_destination = places_for_the_cards * len(player_hand)
def update_cards_x_adjustment() -> None:
    global cards_x_adjustment

    # this number represents the interval of all the possible x position any card can be
    # which is:  0 <= X <=  cards_line_length
    cards_line_length = SCREEN_WIDTH - CARD_WIDTH * CARD_SIZE

    # we get the last card x Value to know the length of the player hand
    last_card_x_pos = (cards_line_length / max_cards) * (max_cards - 1)

    # then the right side gap will be as follows
    right_side_gap = (SCREEN_WIDTH - last_card_x_pos - (CARD_WIDTH * CARD_SIZE))

    # we only want half of it to adjust the cards
    cards_x_adjustment = right_side_gap / 2
def update_timers() -> None:
    # we just call the update() method for all timers to check if they are finished
    global timers

    for timer in timers.keys():
        timers[timer].update()
def update_score_shake_and_color() -> None:
    global score, target, score_color, shake_score, shake_score_amount, score_reached_color

    # if the score have reached the target
    if score >= target:
        # change the color of the score
        score_color = score_reached_color
    else:
        # do nothing or reset the score_color
        score_color = TEXT_COLOR

    # if the score surpassed the target by 150%
    if score >= target * 1.5:

        # turn on the score shake animation
        shake_score = True

        # the ratio between the score and 150% of the target, ratio starts at 1 and each time the score increases
        # the ratio get smaller and smaller
        ratio = (target * 1.5) / score

        # multiply the green RGB value by the ratio and this will shift the color to become more red
        score_reached_color = [255, 255 * ratio, 0]

        # the score shake will increase alongside with the score
        shake_score_amount = score // target
def update_moving_card() -> None:
    # this function is responsible for moving the card that has been drawn and the deck reset part 1 animation

    global player_hand, card_is_moving_to_hand, x_destination, card_is_moving_from_deck
    global deck_of_cards_reset_part1, deck_of_cards_reset_part2, deck_of_cards

    # first we check is there a moving card from the deck to the side of the screen
    # in other words, is the card_is_moving_from_deck animation is on
    if card_is_moving_from_deck:

        # we get the moving card dictionary tha holds the image and X&Y from the deck images list
        moving_card_dictionary = deck_of_cards.cards_back_images[deck_of_cards.size]

        # check if the X positions has not reached the out-side the screen.
        if moving_card_dictionary['x'] + DECK_OF_CARDS_SPEED < SCREEN_WIDTH + 50:

            # move the top deck card to the right by the speed
            moving_card_dictionary['x'] += DECK_OF_CARDS_SPEED

        # if its reached its destination
        else:
            # stop the card_is_moving_from_deck animation
            card_is_moving_from_deck = False

            # and start the card_is_moving_to_hand animation
            card_is_moving_to_hand = True

    # then, we check is there a moving card to the hand
    elif card_is_moving_to_hand:

        # logically the moving card is the last card in the player hand
        moving_card = player_hand[-1]

        # we check if we shift the moving card to the left by
        # CARD_SPEED will it be still on the right side of the x_destination
        if moving_card.x - CARD_SPEED > x_destination:
            # if yes shift the moving card
            moving_card.x -= CARD_SPEED

        else:
            # the moving card has reached the destination
            moving_card.x = x_destination

            # now, there is no moving cards
            card_is_moving_to_hand = False

    # then, we check if the deck reset part 1 animation is on
    elif deck_of_cards_reset_part1:

        # move all the cards in the deck to the right by (DECK_OF_CARDS_SPEED / 3)
        for i in range(deck_of_cards.size):
            deck_of_cards.cards_back_images[i]['x'] += DECK_OF_CARDS_SPEED / 3

        # check if the deck X position is out-side the screen
        # note: all the cards share the same X value
        if deck_of_cards.cards_back_images[0]['x'] > SCREEN_WIDTH + 50:
            # stop part1 and start part2 animation
            deck_of_cards_reset_part1 = False
            deck_of_cards_reset_part2 = True

            # reset the deck of cards
            deck_of_cards = Deck_of_cards()
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of Update Functions

# start of One Time Called Functions
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# these functions are used to initialize some variables before the Game-Loop starts
def get_background_rect(width, height):
    # this function returns the rectangles used in the
    # 1 - the title | 2 - the title buttons | 3 - the reset options rectangle
    # it only asks for the width and height of the rectangle

    # creating an empty image with a dimension of -> (width x height)
    background_rect = pygame.Surface((width, height)).convert_alpha()
    # fill the image with black color
    background_rect.fill("black")

    # initializing the red rectangle that will be inside the bigger rectangle (background_rect)
    # the size of this rectangle is smaller by (OUTLINE_SIZE * 2) to give the black outline
    RED_RECT = pygame.Surface((width - OUTLINE_SIZE * 2, height - OUTLINE_SIZE * 2)).convert_alpha()
    RED_RECT.fill(RECT_COLOR)

    # draw RED_RECT in the center (OUTLINE_SIZE, OUTLINE_SIZE) of the background_rect
    background_rect.blit(RED_RECT, [OUTLINE_SIZE, OUTLINE_SIZE])

    # return the result
    return background_rect
def get_card_back_image(color: str) -> pygame.surface.Surface:
    # this function returns the back of the (black/red) cards from the sprite sheet, it is used to draw the deck
    # it has the same logic as get_image() method in the Card class

    # the X location for the two cards are the same
    card_x = 14 * CARD_WIDTH

    # if we cant a black card
    if color == 'black':
        # the Y value goes to the third row
        card_y = 2 * CARD_HEIGHT

    elif color == 'red':
        # the Y value goes to the fourth row
        card_y = 3 * CARD_HEIGHT

    # this part is for getting the image from the sprite sheet
    # logic that has been explained before
    card_back_image = pygame.Surface((CARD_WIDTH, CARD_HEIGHT)).convert_alpha()
    card_back_image.blit(CARDS_SPRITE_SHEET, [0, 0], [card_x, card_y, card_x + CARD_WIDTH, card_y + CARD_HEIGHT])
    card_back_image = pygame.transform.scale(card_back_image,
                                             [CARD_WIDTH * DECK_OF_CARDS_SIZE, CARD_HEIGHT * DECK_OF_CARDS_SIZE])

    # the new thing is we rotate the image to give a 3D effect
    card_back_image = pygame.transform.rotate(card_back_image, DECK_OF_CARDS_ROTATION)

    card_back_image.set_colorkey('black')

    # return the image
    return card_back_image
def get_button_image(button_type:str):
    # this function return the green and red buttons from the sprite sheet

    # the sizes of the buttons got from the sprite sheet
    button_width = 16
    button_height = 16

    # getting the col and row of the desired button from the sprite sheet
    if button_type == "green":
        col = 0
        row = 0

    elif button_type == 'red':
        col = 0
        row = 3

    # create the button image
    image = pygame.Surface((button_width, button_height)).convert_alpha()

    # getting the X&Y value
    sprite_x = button_width * col
    sprite_y = button_height * row

    # cutting the button image form the sheet
    image.blit(BUTTONS_SPRITE_SHEET, [0, 0], [sprite_x , sprite_y, sprite_x + button_width, sprite_y + button_height])

    # creating the small black rectangle that is inside the button to hold the small text on it
    black_rect = pygame.surface.Surface((image.get_width(), BUTTONS_BLACK_RECT_HEIGHT)).convert_alpha()
    black_rect.fill('black')

    # black_rect_y stores the Y position that will align the rectangle in the middle of the button
    black_rect_y = (image.get_height() - BUTTONS_BLACK_RECT_HEIGHT)/2

    # draw the black_rect into button image
    image.blit(black_rect, [0 , black_rect_y])

    # return the button image
    return image
def get_suit_image(suit: str):

    # this function returns the suit image in the cards top left corner form the cards sprite sheet

    # all suits share the same width and X position
    suit_width = 4
    suit_x = 4

    # each suit has its unique suit_height and Y position from the sprite sheet
    if suit == 'Hearts':
        suit_height = 4
        suit_y = 113
    elif suit == 'Clubs':
        suit_height = 5
        suit_y = 5
    elif suit == 'Diamonds':
        suit_height = 5
        suit_y = 41
    elif suit == 'Spades':
        suit_height = 6
        suit_y = 76

    # creating an image with a size of (suit_width x suit_height)
    image = pygame.Surface((suit_width, suit_height)).convert_alpha()

    # drawing the suit into the image from the sprite sheet.
    image.blit(CARDS_SPRITE_SHEET, [0, 0], [suit_x, suit_y, suit_x + suit_width, suit_y + suit_height])

    # there will be some white pixels (255, 254, 248) left in the image and this loop will traverse through
    # the image pixels to get rid of them
    for y in range(suit_height):
        for x in range(suit_width):

            # Get the color at (x, y) position
            color = image.get_at((x, y))

            # if it is the desired pixel
            if color == (255, 254, 248, 255):
                # change the color of that pixel to the Background_Color to hide it
                image.set_at([x, y], Background_Color)

    # scale the image because the image is too small to see
    image = pygame.transform.scale(image, [image.get_width() * SUIT_SIZE, image.get_height() * SUIT_SIZE])

    # return the suit image
    return image
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of One Time Called Functions

# start of the Menu Screen Functions
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
def go_to_menu_screen():
    # this function starts the entering animation and call the show_menu_screen()
    global menu_entering
    menu_entering = True
    show_menu_screen()
def show_menu_screen():
    # this massive function is responsible for everything regarding the main menu screen
    global menu_exiting, menu_animation_dt, title_dt, run

    # here are the inner functions for the menu screen
    def get_random_card():

        # this function returns a card with a random value, suit, speed, and X&Y position
        # this card is used for falling in the menu screen background

        # list for all the possibilities
        values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        suits = ['Clubs', 'Diamonds', 'Spades', 'Hearts']

        # getting the random indices
        values_random_index = random.randint(0, len(values) - 1)
        suits_random_index = random.randint(0, len(suits) - 1)

        # the falling card is a random value between FALLING_CARDS_MIN_SPEED and FALLING_CARDS_MAX_SPEED
        falling_speed = random.randint(FALLING_CARDS_MIN_SPEED, FALLING_CARDS_MAX_SPEED)

        # creating the card
        card = Card(values[values_random_index], suits[suits_random_index], speed=falling_speed)

        # setting up the card X value to be a random value that will be inside the screen
        card.x = random.randint(-int(CARD_WIDTH * CARD_SIZE / 1.5), SCREEN_WIDTH - int(CARD_WIDTH * CARD_SIZE / 1.5))

        # setting up the card Y value to be a
        # random value between (-CARD_HEIGHT * int(CARD_SIZE) * 5, -CARD_HEIGHT * int(CARD_SIZE))
        # this range of values will make the falling card be above the screen, however, the random value gained from
        # it will determine the distance between the card and the top side of the screen, thus, controlling when the
        # card will be shown to the player.this is why the falling cards feel random at when to show
        card.y = random.randint(-CARD_HEIGHT * int(CARD_SIZE) * 5, -CARD_HEIGHT * int(CARD_SIZE))

        # return the card
        return card

    def draw_and_move_falling_cards(falling_cards: list):

        # this function draws and move the falling card in each frame

        # the index variable
        i = 0

        # for all falling card
        while i < len(falling_cards):

            # draw them at the screen and y_shift them by the menu_animation_shift if the exiting animation is on
            screen.blit(falling_cards[i].image, [falling_cards[i].x, falling_cards[i].y + menu_animation_shift])

            # if the exiting animation is off
            if not menu_exiting:

                # y_shift the card y value downward by the card speed
                falling_cards[i].y += falling_cards[i].speed

                # if the card is beneath the screen
                if falling_cards[i].y >= SCREEN_HEIGHT:

                    # delete the card from the list of falling cards
                    del falling_cards[i]

                    # add to the list of falling card a random card
                    falling_cards.append(get_random_card())

                    # decrement the index variable after deletion
                    i -= 1

            # increment the index variable at the end of the loop
            i += 1

    def update_menu_animation_shift():

        global menu_exiting, menu_entering, menu_animation_shift, menu_animation_dt, title_dt, show_menu

        # if exiting animation is on
        if menu_exiting:

            # assign the y_shift
            menu_animation_shift = -2 * (SCREEN_HEIGHT - CARD_HEIGHT * CARD_SIZE) * math.sin(menu_animation_dt)

            # increment the change of time by the speed
            menu_animation_dt += menu_animation_speed

            # if the y_shift reached a certain value,we know that all menu images are shifted above the screen
            # and all game screen images are in their default location
            if menu_animation_shift <= -SCREEN_HEIGHT - CARD_HEIGHT * CARD_SIZE:

                # turn off the exiting animation
                menu_exiting = False
                # reset the y_shift variable
                menu_animation_dt = 0
                menu_animation_shift = 0
                # reset the title change of time
                title_dt = 0
                # turn off the menu screen
                show_menu = False

        # if entering animation is on
        elif menu_entering:

            # assign the y_shift
            menu_animation_shift = 2 * (SCREEN_HEIGHT) * math.sin(menu_animation_dt)

            # increment the change of time by the speed
            menu_animation_dt += menu_animation_speed / 2

            # if the y_shift reached a certain value, we know that all game screen images are shifted below the screen
            # and all menu images are in their default location
            if menu_animation_shift >= SCREEN_HEIGHT:
                # turn off the entering animation
                menu_entering = False
                # reset the y_shift variable
                menu_animation_dt = 0
                menu_animation_shift = 0

    def draw_buttons():

        # if entering animation is on
        if menu_entering:
            y_shift = menu_animation_shift - SCREEN_HEIGHT

        # if exiting animation is on
        elif menu_exiting:
            y_shift = menu_animation_shift

        # if no animation is on
        else:
            # the menu buttons hovering animation goes in the opposite direction from the title
            # and dividing the hovering speed by 8
            y_shift = -title_hovering / 8

        # the X position of the background rectangle is the left button X value shifted by
        # MENU_BUTTONS_RECT_HORIZONTAL_DISTANCE to the left
        rect_x = min(start_button.x, exit_button.x) - MENU_BUTTONS_RECT_HORIZONTAL_DISTANCE

        # the Y position of the background rectangle is the buttons Y value shifted upwards by
        # MENU_BUTTONS_RECT_HORIZONTAL_DISTANCE
        rect_y = MENU_BUTTONS_Y - MENU_BUTTONS_RECT_HORIZONTAL_DISTANCE

        # draw the rectangle and the buttons with y_shift for animations
        screen.blit(MENU_BUTTONS_RECT_IMAGE, [rect_x, rect_y + y_shift])
        start_button.draw(y_shift)
        exit_button.draw(y_shift)

        # small text "START" and "EXIT" Y position
        small_texts_y = start_button.y + start_button.image.get_height()/2 - 19

        start_x = start_button.x + START_X_SHIFT_FROM_BUTTON_X
        exit_x = exit_button.x + EXIT_X_SHIFT_FROM_BUTTON_X

        # drawing the small texts
        screen.blit(START_IMAGE, [start_x, small_texts_y + y_shift])
        screen.blit(EXIT_IMAGE, [exit_x, small_texts_y + y_shift])

    def check_menu_buttons():
        # this function check if the menu buttons got presses

        global menu_exiting, run

        # if not major animation is on
        if not menu_entering and not menu_exiting:

            # check if the start button is pressed
            if start_button.is_pressed():

                # start the exiting animation
                menu_exiting = True

            # check if the exit button is pressed
            elif exit_button.is_pressed():

                # turn off the program
                run = False

    def draw_title():
        global title_dt, title_hovering

        # if the entering animation is on
        if menu_entering:
            shift = menu_animation_shift - SCREEN_HEIGHT

        else:
            shift = menu_animation_shift + title_hovering

        # draw the menu title image
        screen.blit(MENU_IMAGE, [RECT_X, RECT_Y + shift])

    def update_title_hovering():
        global title_hovering, title_dt

        # if no major animation is on
        if not menu_entering and not menu_exiting:
            # increment the change of time
            title_dt += TITLE_SPEED
            # make dt between (0 , 2PI)
            title_dt %= 2 * math.pi
            # assign the new hovering value
            title_hovering = TITLE_MOVING_DISTANCE / 2 * math.sin(title_dt)

    def draw_highest_level():

        # if entering animation is on
        if menu_entering:
            y_shift = menu_animation_shift - SCREEN_HEIGHT

        # if exiting animation is on
        elif menu_exiting:
            y_shift = menu_animation_shift

        # if no animation is on
        else:
            # the menu buttons hovering animation goes in the opposite direction from the title
            # and dividing the hovering speed by 8
            y_shift = -title_hovering / 8

        # we get the text image
        highest_level_image = SMALL_FONT.render(f'HIGHEST LEVEL {current_highest_level}', True, TEXT_COLOR)

        # setting up the X&Y values
        text_x = min(start_button.x, exit_button.x) + 80
        text_y = MENU_BUTTONS_Y + start_button.image.get_height() + 15

        # draw the highest level
        screen.blit(highest_level_image, [text_x, text_y + y_shift])

    current_highest_level = read_highest_level()

    # initialize the falling cards list
    falling_cards = []

    # add 10 random cards to the list
    for i in range(10):
        falling_cards.append(get_random_card())

    # initialize show_menu, the menu turns off if it becomes False
    global show_menu
    show_menu = True

    # start of menu game loop
    while show_menu and run:

        # refresh the screen
        screen.fill(Background_Color)
        # run the program at 60 frames per second
        clock.tick(FPS)

        # call the draw funcitons:

        # draw the falling cards if the entering animation is off
        if not menu_entering:
            draw_and_move_falling_cards(falling_cards)

        draw_title()
        draw_buttons()
        draw_highest_level()


        # draw the game screen images of a major animation is on
        if menu_exiting or menu_entering:
            draw_deck_of_cards()
            draw_texts()
            draw_symbols()

        # call the update functions
        update_title_hovering()
        update_menu_animation_shift()

        # check the menu buttons
        check_menu_buttons()

        # the event handler
        for event in pygame.event.get():
            # if the player pressed the quit button
            if event.type == pygame.QUIT:
                # shut down the program
                run = False

        # if the exiting shift reached the desired value
        if menu_exiting and menu_animation_shift <= -SCREEN_HEIGHT - CARD_HEIGHT * CARD_SIZE:
            # turn off menu screen
            show_menu = False

        # show to the player the new screen
        show_display()
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of the Menu Screen Functions

# start of Action Functions
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
def draw() -> None:
    # this function draws a cards to the player hand
    global player_hand, deck_of_cards

    # if the deck is not empty
    if deck_of_cards.size > 0:
        # add a card to the player hand list from the deck
        player_hand.append(deck_of_cards.draw())

    # if the deck is empty
    if deck_of_cards.size == 0:
        # activate the reset deck timer
        timers['reset deck'].activate()
def reset_messages() -> None:
    # reset the messages alpha value and delete all the messages except the score and multiplier

    global messages, alpha_value

    # reset the alpha_value to show all the messages that will pop out
    alpha_value = DEFAULT_ALPHA_VALUE

    messages = {'score': messages['score'],
                'multiplier': messages['multiplier']
                }
def set_slide_out() -> None:
    # this function will set the slide out animation to on

    global set_slide_out, slide_dt, slide_out, SIN_COEFFICIENT, LOCAL_MINIMUM

    # turn on the animation
    slide_out = True
    # this is the solution of the equation -> COSTUME_SIN_FUNCTION(t) = 1
    # dt will start at the point (dt, 1)
    slide_dt = math.asin((1 - SIN_COEFFICIENT - LOCAL_MINIMUM) / SIN_COEFFICIENT)
def show_reset_opiton():
    # this function will start showing the reset option
    global reset_option_entering, reset_option_is_on
    reset_option_is_on = True
    reset_option_entering = True
def reset_deck_of_cards():
    global deck_of_cards_reset_part1, deck_of_cards_reset_part2, deck_of_cards

    # if the deck is not empty
    if deck_of_cards.size > 0:
        # activate part 1 of the animation
        deck_of_cards_reset_part1 = True

    # if it is empty
    else:
        # activate part 2 of the animation
        deck_of_cards_reset_part2 = True
        # reset the deck
        deck_of_cards = Deck_of_cards()
def screen_shake_on():
    # this function will start the screen shake
    global screen_shake

    # if the screen shake animation is on and the screen shake timer is not active
    if screen_shake and not timers['screen shake off'].active:
        # turn off screen shake
        screen_shake = False

    # if screen shake is off
    elif not screen_shake:
        # turn on screen shake
        screen_shake = True
        # and activate the timer that will stop the screen shake after a short duration
        timers['screen shake off'].activate()
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# end of Action Functions

''' end of TURKI`s implementation (ID: 5554912)----------------------------------------------------------------------'''

''' start of LAMA`s implementation (ID: 5555093)---------------------------------------------------------------------'''

# import the mixer module from the Pygame library in order to add and control the sounds within the game
from pygame import mixer

# pre-initialization(values so we can make sure it works properly)
pygame.mixer.pre_init(44100, -16, 2, 512)

# initialize
mixer.init()


# variables
SOUNDS_VOLUME = 0.4
MUSIC_DELAY = 4000
MUSIC_VOLUME = 0.6

BUTTONS_BLACK_RECT_HEIGHT = 6
BUTTONS_SPRITE_SHEET = pygame.image.load('button UI.png').convert_alpha()

# stores button images in a dictionary
button_images = {

    'green': get_button_image('green'),
    'red': get_button_image('red')
}

# scale factor
size = 10

#calculations to ensure that both buttons are horizontally centered on the screen with appropriate spacing between them.
MENU_BUTTONS_Y = SCREEN_HEIGHT / 2 + 100
START_X = (SCREEN_WIDTH - button_images['green'].get_width() * size) / 2 - button_images['green'].get_width() * size
EXIT_X = (SCREEN_WIDTH - button_images['green'].get_width() * size) / 2 + button_images['green'].get_width() * size

#calculations to ensure that the option buttons are positioned appropriately relative to the reset option and each other
OPTION_BUTTONS_Y = RESET_OPTION_Y + RESET_OPTION_HEIGHT - button_images['green'].get_height() * size - OUTLINE_SIZE
YES_X = RESET_OPTION_X + OUTLINE_SIZE + OPTION_BUTTONS_RECT_HORIZONTAL_DISTANCE
NO_X = RESET_OPTION_X + RESET_OPTION_WIDTH - OUTLINE_SIZE - OPTION_BUTTONS_RECT_HORIZONTAL_DISTANCE \
       - button_images['green'].get_width() * size
NO_Y = SCREEN_HEIGHT / 2
YES_Y = SCREEN_HEIGHT / 2

# load sounds in a dictionary
sounds = {
    'one_card': pygame.mixer.Sound('card.wav'),
    'button_click': pygame.mixer.Sound('button_click.wav'),
    'reset_cards' : pygame.mixer.Sound('reset_cards_sound.wav'),
    'end_level':pygame.mixer.Sound('end_level_sound.wav'),
    'lose_sound': pygame.mixer.Sound('lose_sound.wav')
}


# setting sounds volum by for loop
for sound_name in sounds:
    sounds[sound_name].set_volume(SOUNDS_VOLUME)

# load background sound (we donot have to sighn avairable bec. it will always plays in backgraound)
pygame.mixer.music.load("background_sound.wav")
pygame.mixer.music.set_volume(MUSIC_VOLUME)

# play the background sound with 4000 ms delay that more comfortable for users since it does not start strong ,and -1 for looping indefinitely
pygame.mixer.music.play(-1, 0.0, MUSIC_DELAY)



# creat a button class to add and control buttons in the game
class Button():
    # Adding scale parameter in case we need to resize the images
    def __init__(self, x: float, y: float, image: pygame.Surface, scale):
        # to adjest images, we first need to know the original dimentions
        width = image.get_width()
        height = image.get_height()

        # assign the scaled version of the image, and multiply both width & height by the scale
        self.image = pygame.transform.scale(image, [int(width * scale), int(height * scale)])

        # store the x and y to the object
        self.x = x
        self.y = y

        # in order to click the button once and release it before click it again
        self.clicked = False

    def draw(self, shift=0) -> None:
        # draw button on screen
        # 'shift' is used for animations
        screen.blit(self.image, (self.x, self.y + shift))

    # to know if user pressed the button
    def is_pressed(self):
        # instance variable so we can return it in order to make each button does different thing
        action = False
        # the idea is to click the buttons by left side button of the mouse to do that:

        # get mouse position
        mouse_pos = pygame.mouse.get_pos()

        # store the xy mouse position in an easy and readable way
        m_x = mouse_pos[0]
        m_y = mouse_pos[1]

        # to check if the mouse over one of buttons and clicked conditions
        # the mouse is inside the button if m_x is between the horizontal side of the button
        # and m_y is between the vertical side of the button
        x_axis_condition = self.x <= m_x and m_x <= self.x + self.image.get_width()
        y_axis_condition = self.y <= m_y and m_y <= self.y + self.image.get_height()

        mouse_inside_button = x_axis_condition and y_axis_condition


        if mouse_inside_button:

            # for left mouse button -> 0
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                self.clicked = True
                action = True

            if pygame.mouse.get_pressed()[0] == 0:
                self.clicked = False

        return action





# creat Button instances

start_button = Button(START_X, MENU_BUTTONS_Y, button_images['green'], size)
exit_button = Button(EXIT_X, MENU_BUTTONS_Y, button_images['red'], size)
yes_button = Button(YES_X, OPTION_BUTTONS_Y, button_images['green'], size)
no_button = Button(NO_X, OPTION_BUTTONS_Y, button_images['red'], size)


# to calculate score
def calculate_score(amount=0) -> None:
    global score, player_hand
   
    # round the amount to the first decimal place
    added_score = round((player_hand[-1].val + amount) * multiplier, 1)

    # send the message
    messages['score'] = f"+{added_score}"

    # add the value of the last card drawn + any bonus amount, then apply multiplier
    score += added_score
    score = round(score, 1)



highest_level_file_name = "highest_level.txt"

#to read the highest level achieved by the player from a file
def read_highest_level():
    try:
        with open(highest_level_file_name, "r") as file:
            file_level = int(file.read().strip())
    except:
        file_level = 1
        write_highest_level(file_level)
    return file_level

# to write the highest level achieved by the player to a file
def write_highest_level(level):
    with open(highest_level_file_name, "w") as file:
        file.write(str(level))

#to update the highest level achieved by the player if the current level is higher.
def update_highest_level(level):
    highest_level = read_highest_level()
    if level > highest_level:
        write_highest_level(level)


''' end of LAMA`s implementation (ID: 5555093)-----------------------------------------------------------------------'''
''' start of ARDA`s implementation ----------------------------------------------------------------------'''
pygame.display.set_caption("White Sparrow") # To name game window "White Sparrow".
# Special Conditions:
# Flags for tracking bonuses.


special_cases = {
        "ace bonus": True,
        "royal bonus" : True,
}

seven_bonus = True

def check_all_speical_cases(): # Function to check special cases.

    global max_cards

    amount_to_add_to_score = 0

    if special_cases['ace bonus'] and all_aces_drawn(): # Checks if the ace bonus is enabled and all aces are drawn.

        max_cards += 1
        messages["ace_bonus_activated"] = "All Aces"

        special_cases['ace bonus'] = False # Disable ace bonus after activation.

    if special_cases["royal bonus"] and royal_family_bonus(): # Checks if the royal bonus is enabled and royal family cards are drawn.

        amount_to_add_to_score += 14
        messages['royal_activated'] = "Royal Family"

        special_cases["royal bonus"] = False # Disable royal bonus after activation.

    calculate_score(amount_to_add_to_score) # Updating the score.

def score_x2target_bonus(): # Function to increase multiplier if score is twice as the target.
    global score, target, multiplier
    while 2 * target < score:
        multiplier += 0.2
        break # Exit the loop after applying the bonus.

def all_aces_drawn():  # Function to award a bonus if all aces are drawn.
    global max_cards, ace_bonus, player_hand
    aces = 0  # To count aces.
    for card in player_hand:
        if card.val == 1:  # Adding 1 ace to the count if the player draw an ace.
            aces += 1

    # returns if all aces are drawn and if the bonus is not activated before.
    return aces == 4 and not ace_bonus

def if_consecutive_drawn():  # Funtion to award a bonus if consecutive cards are drawn.
    global target
    if len(player_hand) > 1:
        last_card = player_hand[-2].val
        new_card = player_hand[-1].val
        if last_card == new_card:
            target -= 3
            messages["consecutive_bonus_activated"] = "Consecutive"
def royal_family_bonus():  # Function to give player a bonus if they draw all royal cards(Q,K,J).
    global score, messages, player_hand
    royal_count = {11: 0, 12: 0, 13: 0}
    for card in player_hand:
        if card.val in royal_count:
            royal_count[card.val] += 1

    # Checks if there is one of each royal card.
    return royal_count[11] and royal_count[12] and royal_count[13]
    # return all(count == 1 for count in royal_count.values())

# Lucky Seven Bonus
class Graph:  # Functions required for a simple graph.
    def __init__(self):
        self.vertices = {}
        self.ajd_matrix = None

    def add_vertex(self, data):
        if data not in self.vertices:
            self.vertices[data] = []

    def del_vertex(self, data):
        if data in self.vertices:
            del self.vertices[data]

    def add_edge(self, data1, data2):
        if data1 in self.vertices and data2 in self.vertices:
            self.vertices[data1].append(data2)
            self.vertices[data2].append(data1)
def lucky_seven_graph():  # Funtion to make a graph with multiple nodes one being lucky.
    graph = Graph()
    nodes = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
             '20']
    for node in nodes:
        graph.add_vertex(node)
    for i in range(len(nodes) - 1):
        graph.add_edge(nodes[i], nodes[i + 1])
    lucky_node = '7'
    return graph, lucky_node
lucky_graph, lucky_node = lucky_seven_graph()  # Initialising the graph.
current_node = '1'  # Starting node
def check_lucky_seven(current_node, lucky_node):
    global score, seven_bonus
    if current_node == lucky_node and not seven_bonus:  # If current node is lucky node and seven bonus is not activated double the score.
        score *= 2
        seven_bonus = True
        print("Lucky Seven activated")
def lucky_seven_bonus():  # The main function that checks if the seven is drawn and the conditions are met.
    global current_node, lucky_node
    for card in player_hand:
        if card.val == 7:
            check_lucky_seven(current_node, lucky_node)
        current_node = random.choice(lucky_graph.vertices[current_node])  # To change current node to a random node.
# Ending level, prepearing next level, ending the game.
def reset_bonuses():  # Reseting bonuses to default.
    global ace_count, royal_count, ace_bonus, royal_bonus, seven_bonus
    ace_bonus = False
    royal_bonus = False
    seven_bonus = False
    royal_count = {11: 0, 12: 0, 13: 0}
    ace_count = 0
def reset_shake():  # Reseting screen shake effects.
    global shake_score, shake_score_amount
    shake_score = False
    shake_score_amount = 0
def player_lost():  # Handling the player losing scenario.
    global score, level, target
    sounds['lose_sound'].play()

    update_highest_level(level)
    messages['highest_level'] = read_highest_level()

    go_to_menu_screen()
    messages['player_lost'] = "You lost!"
    level = 1
    target = 20
    score = 0
def end_level():  # Ends current level either finishes the game or advance player to the next level.
    global player_hand, score, messages, target, level, max_cards, score_color
    # Clearing the players hand and reseting some values to default.
    score_x2target_bonus()
    player_hand = []
    reset_bonuses()
    reset_shake()
    score_color = TEXT_COLOR
    if score >= target:
        messages['end_level'] = "Next level"
        level += 1
        target += target_increment  # Increasing target score for the next level.
        score = 0
        sounds['end_level'].play()
    else:  # If target score is not met ,end the game.
        multiplier = 1
        update_highest_level(level)
        player_lost()
''' end of ARDA`s implementation------------------------------------------------------------------------'''

def update_all() -> None:

  # it makes the program run at 60 FPS
  clock.tick(FPS)

  # here where the fill the screen with pink all of it.
  # and if you don`t understant why we do that every frame, then try to remove this line and run the program
  screen.fill(Background_Color)

  draw_symbols()

  # here we draw all of the text in the top left corner
  draw_texts()

  # here we draw the cards in the screen
  draw_hand()

  # here we draw the deck_of_cards in the screen
  draw_deck_of_cards()

  # here we move the card that is being drawn if the (card_is_moving_to_hand is True)
  update_moving_card()

  # TODO we need to move this function to the place where we start each level.
  #  we only need to update the value at the begging of every level not every frame
  update_cards_x_adjustment()

  #we update all of the timers to check if they are finished
  update_timers()

  draw_messages()

  draw_and_move_reset_option()

  # Note: we call this function in every frame. 60 times per second
  show_display()


# images loading
# -----------------------
black_card_back_image = get_card_back_image('black')
red_card_back_image = get_card_back_image('red')

suit_images = {
    'Clubs': get_suit_image('Clubs'),
    'Diamonds': get_suit_image('Diamonds'),
    'Spades': get_suit_image('Spades'),
    'Hearts': get_suit_image('Hearts')
}

RESET_OPTION_IMAGE = get_background_rect(RESET_OPTION_WIDTH, RESET_OPTION_HEIGHT)
RESET_OPTION_IMAGE.blit(WANT_TO_RESET_IMAGE, [WANT_TO_RESET_X, WANT_TO_RESET_Y])
RESET_OPTION_IMAGE.blit(THE_DECK_IMAGE, [THE_DECK_X, THE_DECK_Y])


MENU_IMAGE = get_background_rect(RECT_WIDTH, RECT_HEIGHT)
MENU_IMAGE.blit(TITLE_IMAGE, [TITLE_X + OUTLINE_SIZE, TITLE_Y + OUTLINE_SIZE])
MENU_IMAGE.blit(WELCOME_IMAGE, [WELCOME_X + OUTLINE_SIZE, WELCOME_Y + OUTLINE_SIZE])

max_x = max(start_button.x, exit_button.x)
min_x = min(start_button.x, exit_button.x)
MENU_BUTTONS_RECT_WIDTH = max_x + start_button.image.get_width() + 2 * MENU_BUTTONS_RECT_HORIZONTAL_DISTANCE - min_x
MENU_BUTTONS_RECT_HEIGHT = start_button.image.get_height() + 2 * MENU_BUTTONS_RECT_VERTICAL_DISTANCE + 50
MENU_BUTTONS_RECT_IMAGE = get_background_rect(MENU_BUTTONS_RECT_WIDTH, MENU_BUTTONS_RECT_HEIGHT)

# -----------------------

# game sitting variables
#-----------------------
player_hand = []
deck_of_cards = Deck_of_cards()
level = 1
max_cards = 5
score = 0
target = 20
target_increment = 5
multiplier = 1
#-----------------------


# timers initialising
# -----------------------
timers = {
    # we dont wont the second the player draw the last card, the level ends. with this timer it solves this issue
    'end level': Timer(3000, function=end_level),

    'card slide': Timer(1000, function=set_slide_out),

    'screen shake off': Timer(SCREEN_SHAKE_TIME, function=screen_shake_on),

    'reset deck': Timer(500, function=reset_deck_of_cards)
}
# -----------------------


global run
run = True

show_menu_screen()

# show_reset_opiton()

# Game Loop ------------------------------
while run:

    # update everything for this frame
    update_all()

    # the event handler
    for event in pygame.event.get():

        key = pygame.key.get_pressed()

        # shut down the program of the player preses the X symbol in the screen
        if event.type == pygame.QUIT:
            run = False

        # if the player presses any key
        elif event.type == pygame.KEYUP or event.type == pygame.MOUSEBUTTONUP:

            condition1 = card_is_moving_from_deck or card_is_moving_to_hand or reset_option_is_on
            condition2 = deck_of_cards_reset_part1 or deck_of_cards_reset_part2 or slide_out
            condition3 = (deck_of_cards.size == 0)
            animation_is_going = condition1 or condition2 or condition3

            deck_is_empty = deck_of_cards.size == 0

            # it is True if there is no animation and the deck is not empty and the player can draw more cards
            acceptable_click = not animation_is_going and not deck_is_empty and len(player_hand) < max_cards

            if acceptable_click:

                # start moving the card from the deck to the right side of the screen
                card_is_moving_from_deck = True

                # There is a card moving now so play a card sound
                sounds['one_card'].play()

                # reset messages' alpha value and delete all the messages except the score
                reset_messages()

                # update the x destination for the new card that has been drawn
                update_X_destination()

                # draw a card
                draw()

                lucky_seven_bonus()
                if_consecutive_drawn()
                check_all_speical_cases()


                update_score_shake_and_color()

                # if the player draws the maximum amount of cards
                if len(player_hand) == max_cards:
                    timers['card slide'].activate()

                    # activate the timer for ending the level. because we want to
                    # give the player a couple of seconds to see what he/she has drawn
                    timers['end level'].activate()

pygame.quit()
